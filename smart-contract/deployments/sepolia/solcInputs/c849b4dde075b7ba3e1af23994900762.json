{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/Charity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\r\nimport \"./PriceConverter.sol\";\r\n\r\nerror Charity__NotOwner();\r\nerror Charity__DonationIsClosed();\r\nerror Charity__NotEnoughAmountEntered();\r\nerror Charity__TransferedFailed();\r\nerror Charity__InsufficientFund();\r\nerror Charity__DonationNotRefundable();\r\n\r\ncontract Charity is ReentrancyGuard{\r\n    using PriceConverter for uint256;\r\n\r\n    enum DonationState{\r\n        OPEN,\r\n        CLOSED\r\n    }\r\n\r\n    enum DonationCategory {\r\n        EDUCATION,\r\n        HEALTHCARE,\r\n        POVERTY,\r\n        DISASTER,\r\n        ENVIRONMENT,\r\n        ANIMAL,\r\n        INFRASTRUCTURE,\r\n        HUMAN_RIGHT,\r\n        EMPOWERMENT\r\n    }\r\n\r\n    struct DonationHistory{\r\n        bytes32 donationId;\r\n        address donater;\r\n        uint256 amount;\r\n        string message;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct Donation {\r\n        bytes32 id;\r\n        address owner;\r\n        address donationTarget;\r\n        string title;\r\n        uint256 priceTarget;\r\n        string description;\r\n        uint256 endTime;\r\n        DonationState state;\r\n        DonationCategory category;\r\n        bool refundable;\r\n        string refundMessage;\r\n        uint256 donationRaised;\r\n        uint256 donationWithdrawed;\r\n        address[] donater;\r\n        string imgUrl;\r\n        mapping (address => DonationHistory[]) donaterToDonateHistory;\r\n        mapping (address => bool) isDonater;\r\n        mapping (address => uint256) donaterToAmount;\r\n    }\r\n\r\n    Donation[] private s_donations;\r\n    DonationHistory[] private s_donationHistories;\r\n    mapping(address => uint256[]) private s_ownerToDonations;\r\n    mapping(bytes32 => uint256) private s_idToDonations;\r\n    address[] private s_owner;\r\n    AggregatorV3Interface private immutable i_priceFeed;\r\n    uint256 private constant MINIMUM_DONATION = 10 * 10**18;\r\n\r\n    event DonationCreated(bytes32 indexed donationId, address indexed creator, string indexed title, uint256 timestamp);\r\n    event Donate(bytes32 indexed donationId, address indexed donater, uint256 indexed amount, string message, uint256 timestamp);\r\n    event TargetAchieved(bytes32 indexed donationId);\r\n    event DonationEnded(bytes32 indexed donationId, address target, uint256 donationAmount);\r\n    event TimeExtended(bytes32 indexed donationId, uint256 indexed time);\r\n    event Withdrawed(bytes32 indexed donationId, uint256 indexed withdrawAmount);\r\n    event RefundIssued(bytes32 indexed donationId, string indexed message);\r\n    event RefundClaimed(bytes32 indexed donationId, address indexed donater, uint256 amount);\r\n\r\n    modifier OnlyOwner(bytes32 donationId){\r\n        if(s_donations[s_idToDonations[donationId]].owner != msg.sender){\r\n            revert Charity__NotOwner();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier IsOpen(bytes32 donationId){\r\n        Donation storage donation = s_donations[s_idToDonations[donationId]];\r\n        if(s_donations[s_idToDonations[donationId]].state == DonationState.CLOSED || block.timestamp >= donation.endTime){\r\n            revert Charity__DonationIsClosed();\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _priceFeedAddress\r\n    ) {\r\n        i_priceFeed = AggregatorV3Interface(_priceFeedAddress);\r\n    }\r\n\r\n    function createDonation(\r\n        string memory _title,\r\n        uint256 _priceTarget,\r\n        uint256 _endTime,\r\n        address _target,\r\n        string memory _description,\r\n        DonationCategory _category,\r\n        string memory _imgUrl\r\n    ) public {\r\n        address _owner = msg.sender;\r\n\r\n        s_donations.push();\r\n        uint256 donationIndex = s_donations.length - 1;\r\n\r\n        bytes32 donationId = keccak256(\r\n            abi.encodePacked(\r\n                msg.sender,\r\n                block.timestamp,\r\n                _title\r\n            )\r\n        );\r\n\r\n        Donation storage newDonation = s_donations[donationIndex];\r\n        newDonation.id = donationId;\r\n        newDonation.owner = _owner;\r\n        newDonation.title = _title;\r\n        newDonation.priceTarget = _priceTarget * 10**18;\r\n        newDonation.endTime = _endTime;\r\n        newDonation.description = _description;\r\n        newDonation.state = DonationState.OPEN;\r\n        newDonation.donationTarget = _target;\r\n        newDonation.donationRaised = 0;\r\n        newDonation.donationWithdrawed = 0;\r\n        newDonation.refundable = false;\r\n        newDonation.category = _category;\r\n        newDonation.imgUrl = _imgUrl;\r\n\r\n        if(s_ownerToDonations[_owner].length == 0) {\r\n            s_owner.push(_owner);\r\n        }\r\n\r\n        s_ownerToDonations[_owner].push(donationIndex);\r\n        s_idToDonations[donationId] = donationIndex;\r\n\r\n\r\n        emit DonationCreated(donationId, _owner, _title, block.timestamp);\r\n    }\r\n\r\n    function donate(bytes32 donationId, string memory _message) public payable IsOpen(donationId) {\r\n        if(msg.value.getConversionRate(i_priceFeed) < MINIMUM_DONATION){\r\n            revert Charity__NotEnoughAmountEntered();\r\n        }\r\n\r\n        Donation storage donation = s_donations[s_idToDonations[donationId]];\r\n\r\n        if(!donation.isDonater[msg.sender]){\r\n            donation.donater.push(msg.sender);\r\n            donation.isDonater[msg.sender] = true;\r\n        }\r\n\r\n        DonationHistory memory donationHistory = DonationHistory(donationId, msg.sender, msg.value, _message, block.timestamp);\r\n\r\n        donation.donaterToDonateHistory[msg.sender].push(donationHistory);\r\n        donation.donaterToAmount[msg.sender] += msg.value;\r\n        donation.donationRaised += msg.value;\r\n\r\n        s_donationHistories.push(donationHistory);\r\n\r\n        emit Donate(donationId, msg.sender, msg.value, _message, block.timestamp);\r\n\r\n        if(donation.donationRaised >= donation.priceTarget){\r\n            emit TargetAchieved(donationId);\r\n        }\r\n    }\r\n\r\n    function endDonation(bytes32 donationId) public OnlyOwner(donationId) IsOpen(donationId) nonReentrant {\r\n        Donation storage donation = s_donations[s_idToDonations[donationId]];\r\n        donation.state = DonationState.CLOSED;\r\n\r\n        address recipient = donation.donationTarget;\r\n        uint256 amountToTransfer = donation.donationRaised;\r\n\r\n        if(!donation.refundable){\r\n            (bool isSuccess,) = payable(recipient).call{ value: amountToTransfer  }(\"\");\r\n\r\n            if(!isSuccess){\r\n                revert Charity__TransferedFailed();\r\n            }\r\n\r\n        } else {\r\n            amountToTransfer = 0;\r\n        }\r\n        emit DonationEnded(donationId, recipient, amountToTransfer);\r\n    }\r\n\r\n    function setDonationTime(bytes32 donationId, uint256 _newEndTime) public OnlyOwner(donationId) IsOpen(donationId){\r\n        Donation storage donation = s_donations[s_idToDonations[donationId]];\r\n\r\n        donation.endTime = _newEndTime;\r\n\r\n        emit TimeExtended(donationId, _newEndTime);\r\n    }\r\n\r\n    function issueRefund(bytes32 donationId, string memory _message) public OnlyOwner(donationId) IsOpen(donationId){\r\n        Donation storage donation = s_donations[s_idToDonations[donationId]];\r\n\r\n        if(donation.donationWithdrawed != 0 || donation.donationRaised == 0){\r\n            revert Charity__DonationNotRefundable();\r\n        }\r\n        \r\n        donation.refundable = true;\r\n        donation.refundMessage = _message;\r\n\r\n        endDonation(donationId);\r\n\r\n        emit RefundIssued(donationId, _message);\r\n    }\r\n\r\n    function claimRefund(bytes32 donationId, address donater) public nonReentrant {\r\n        Donation storage donation = s_donations[s_idToDonations[donationId]];\r\n        \r\n        if(!donation.refundable){\r\n            revert Charity__DonationNotRefundable();\r\n        }\r\n        \r\n        uint256 refundAmount = donation.donaterToAmount[donater];\r\n        donation.donaterToAmount[donater] = 0;\r\n        donation.donationRaised -= refundAmount;\r\n\r\n        (bool isSuccess,) = payable(donater).call{ value: refundAmount }(\"\");\r\n\r\n        if(!isSuccess){\r\n            revert Charity__TransferedFailed();\r\n        }\r\n\r\n\r\n        emit RefundClaimed(donationId, donater, refundAmount);\r\n    }\r\n\r\n    function withdraw(bytes32 donationId, uint256 withdrawalAmount) public OnlyOwner(donationId) nonReentrant {\r\n        Donation storage donation = s_donations[s_idToDonations[donationId]];\r\n\r\n        uint256 availableBalance = donation.donationRaised - donation.donationWithdrawed;\r\n\r\n        if(availableBalance < withdrawalAmount){\r\n            revert Charity__InsufficientFund();\r\n        }\r\n\r\n        (bool isSuccess,) = payable(donation.donationTarget).call{ value: withdrawalAmount }(\"\");\r\n\r\n        if(!isSuccess){\r\n            revert Charity__TransferedFailed();\r\n        }\r\n        \r\n        donation.donationWithdrawed += withdrawalAmount;\r\n\r\n        emit Withdrawed(donationId, withdrawalAmount);\r\n    }\r\n\r\n    function getPriceFeed() public view returns(AggregatorV3Interface) {\r\n        return i_priceFeed;\r\n    }\r\n\r\n    function getDonationLength() public view returns(uint256){\r\n        return s_donations.length;\r\n    }\r\n\r\n    function getDonationDetails(uint256 index) \r\n        public \r\n        view \r\n        returns (\r\n            bytes32 id, \r\n            address owner, \r\n            address donationTarget, \r\n            string memory title, \r\n            uint256 priceTarget, \r\n            string memory description, \r\n            uint256 endTime, \r\n            DonationState state, \r\n            DonationCategory category,\r\n            bool refundable, \r\n            string memory refundMessage, \r\n            uint256 donationRaised, \r\n            uint256 donationWithdrawed, \r\n            address[] memory donater,\r\n            string memory imgUrl\r\n        ) \r\n    {\r\n        Donation storage donation = s_donations[index];\r\n\r\n        return (\r\n            donation.id,\r\n            donation.owner,\r\n            donation.donationTarget,\r\n            donation.title,\r\n            donation.priceTarget,\r\n            donation.description,\r\n            donation.endTime,\r\n            donation.state,\r\n            donation.category,\r\n            donation.refundable,\r\n            donation.refundMessage,\r\n            donation.donationRaised,\r\n            donation.donationWithdrawed,\r\n            donation.donater,\r\n            donation.imgUrl\r\n        );\r\n    }\r\n\r\n\r\n    function getDonationIndexByOwner(address owner) public view returns(uint256[] memory){\r\n        return s_ownerToDonations[owner];\r\n    }\r\n\r\n    function getDonationIndexById(bytes32 donationId) public view  returns(uint256){\r\n        return s_idToDonations[donationId];\r\n    }\r\n\r\n    function getOwnerLength() public view returns(uint256){\r\n        return s_owner.length;\r\n    }\r\n\r\n    function getOwner(uint256 index) public view returns(address){\r\n        return s_owner[index];\r\n    }\r\n\r\n    function getAllDonationHistory() public view returns(DonationHistory[] memory){\r\n        return s_donationHistories;\r\n    }\r\n\r\n    function getDonationHistory(bytes32 donationId, address owner) public view returns(DonationHistory[] memory){\r\n        DonationHistory[] memory ownerDonateHistory = s_donations[getDonationIndexById(donationId)].donaterToDonateHistory[owner];\r\n        return ownerDonateHistory;\r\n    }\r\n\r\n    function getDonationHistoryLength() public view returns(uint256) {\r\n        return s_donationHistories.length;\r\n    }\r\n\r\n    function getDonationAmount(bytes32 donationId, address owner) public view returns(uint256){\r\n        return s_donations[s_idToDonations[donationId]].donaterToAmount[owner];\r\n    }\r\n\r\n    function getConvertedEthAmount(uint256 ethAmount) public view returns (uint256) {\r\n        return ethAmount.getConversionRate(i_priceFeed);\r\n    }\r\n\r\n    function getEthUsdPrice() public view returns(uint256) {\r\n        return PriceConverter.getPrice(i_priceFeed);\r\n    }\r\n}"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.27;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\r\n\r\nlibrary PriceConverter{\r\n    function getPrice(AggregatorV3Interface priceFeed)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        (, int256 answer,,,) = priceFeed.latestRoundData();\r\n        return uint256(answer * 10**10);\r\n    }\r\n\r\n    function getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeed)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 ethAmountInUsd = (getPrice(priceFeed) * ethAmount) / 10**18;\r\n        return ethAmountInUsd;\r\n    }\r\n}"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}